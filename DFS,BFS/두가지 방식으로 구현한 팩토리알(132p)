#DFS와 BFS를 구현하려면 재귀 함수도 이해하고 있어야 한다.
#재귀함수Recursive Function란 자기 자신을 다시 호출하는 함수를 의미한다.
#재귀함수는 내부적으로 스택 자료구조와 동일하다는 것만 기억하자.
#따라서 스택 자료구조를 활용해야 하는 상당수 알고리즘은 재귀 함수를 이용해서 간편하게 구현될 수 있다. DFS가 대표적인 예이다.

#팩토리알 함수는 n이 1이하가 되었을때 함수를 종요하는 재귀 함수의 형태로 구현할 수 있다.

#<이것이 취업을 위한 코딩이다>, 나동빈 저 132p 중

#---------------------------------------------------------------------
#내코드

#반복을 이용한 팩토리알 구현
def factorial_function(n):
    s=1
    while n>1:
        s*=n 
        n-=1
    return s

n=int(input('n의 값을 입력해주세요. : '))
print('{}!의 값은 {}입니다.'.format(n,factorial_function(n)))   

#---------------------------------------------------------------------
#내코드

#재귀한수를 이용한 팩토리알 구현
def factorial_function(n):
    if n==1:
        return 1
    return n*factorial_function(n-1)

n=int(input('n의 값을 입력해주세요. : '))
print('{}!의 값은 {}입니다.'.format(n,factorial_function(n)))    
 

둘다 결괏값은

"""
input
n의 값을 입력해주세요. : 5
output
5!의 값은 120입니다.
"""

#-----------------------------------------------------------------------

#동빈님 코드

# 반복적으로 구현한 n!
def factorial_iterative(n):        
    result = 1
    # 1부터 n까지의 수를 차례대로 곱하기
    for i in range(1, n + 1):
       result *= i
    return result

# 재귀적으로 구현한 n!
def factorial_recursive(n):        
    if n <= 1: # n이 1 이하인 경우 1을 반환
        return 1
    # n! = n * (n - 1)!를 그대로 코드로 작성하기
    return n * factorial_recursive(n - 1)

# 각각의 방식으로 구현한 n! 출력(n = 5)
print('반복적으로 구현:', factorial_iterative(5))
print('재귀적으로 구현:', factorial_recursive(5))

#-----------------------------------------------------------------------

#재귀함수의 코드가 더 간결해 진 것을 알 수 있다. 간결해진 이유는 재귀함수가 수학의 점화식(재귀식)을 그대로 소스코드로 옮겼기 때문이다.
#수학에서 점화식은 특정한 함수를 자신보다 더 작은 변수에 대한 함수와의 관계로 표현한 것을 의미한다. 
#이 개념은 이후에 배울 8장의 '다이나믹 프로그래밍'으로 이어지기 때문에 중요하다. 

...
#재귀함수 내에서 특정 조건일 때 더 이상 재귀적으로 함수를 호출하지 않고 종료하도록 if문을 이용하여 꼭 종료 조건을 구현해주어야 한다.
#재귀함수의 소스코드와 점화식이 매우 닮아있는 것을 확인할 수 있다.
#다시 말해 재귀함수는 반복문을 이용하는 것과 비교했을 때 더욱 간결한 형태임을 이해할 수 있다.
#<이것이 취업을 위한 코딩이다>, 나동빈 저 133p
